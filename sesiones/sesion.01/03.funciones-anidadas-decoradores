# ğŸ§­ SesiÃ³n 1 Â· Punto 3 â€” Decoradores y funciones anidadas

## ğŸ¯ Objetivos especÃ­ficos

* Comprender quÃ© son las funciones anidadas y cÃ³mo funcionan los *closures*.
* Entender el patrÃ³n de los decoradores en Python.
* Crear decoradores personalizados y conocer los decoradores integrados mÃ¡s comunes.

---

## ğŸ“š Resumen teÃ³rico-prÃ¡ctico

### ğŸ”¹ Funciones anidadas

Una funciÃ³n puede definirse dentro de otra, y puede acceder a variables del Ã¡mbito exterior.

```python
def exterior(mensaje):
    def interior():
        print(f"Hola {mensaje}")
    return interior

saludo = exterior("Python")
saludo()  # Hola Python
```

ğŸ‘‰ `interior` â€œrecuerdaâ€ el valor de `mensaje` aunque `exterior` ya haya terminado â†’ esto se llama **closure**.

---

### ğŸ”¹ Closures prÃ¡cticos

Sirven para generar funciones personalizadas dinÃ¡micamente:

```python
def potencia(exp):
    def elevar(base):
        return base ** exp
    return elevar

cuadrado = potencia(2)
print(cuadrado(5))  # 25
```

---

### ğŸ”¹ Decoradores bÃ¡sicos

Un **decorador** es una funciÃ³n que recibe otra funciÃ³n y devuelve una nueva, normalmente aÃ±adiendo comportamiento extra.

```python
def mi_decorador(func):
    def wrapper(*args, **kwargs):
        print("Antes de ejecutar")
        resultado = func(*args, **kwargs)
        print("DespuÃ©s de ejecutar")
        return resultado
    return wrapper

@mi_decorador
def saludar(nombre):
    print(f"Hola {nombre}")

saludar("Ana")
```

---

### ğŸ”¹ Decoradores Ãºtiles en la prÃ¡ctica

* **Logging**

```python
def log(func):
    def wrapper(*args, **kwargs):
        print(f"[LOG] {func.__name__} con {args} {kwargs}")
        return func(*args, **kwargs)
    return wrapper

@log
def sumar(a, b):
    return a + b
```

* **MediciÃ³n de tiempo**

```python
import time

def cronometro(func):
    def wrapper(*args, **kwargs):
        inicio = time.time()
        resultado = func(*args, **kwargs)
        print(f"TardÃ³ {time.time()-inicio:.4f}s")
        return resultado
    return wrapper
```

* **Control de acceso**

```python
def requiere_admin(func):
    def wrapper(*args, rol=None, **kwargs):
        if rol != "admin":
            raise PermissionError("Acceso denegado")
        return func(*args, **kwargs)
    return wrapper
```

---

### ğŸ”¹ Decoradores con parÃ¡metros

Un decorador puede recibir sus propios argumentos:

```python
def repetir(n):
    def decorador(func):
        def wrapper(*args, **kwargs):
            for _ in range(n):
                func(*args, **kwargs)
        return wrapper
    return decorador

@repetir(3)
def hola():
    print("Hola!")

hola()  
# Se imprime 3 veces
```

---

### ğŸ”¹ Decoradores en la librerÃ­a estÃ¡ndar

* `@staticmethod` â†’ mÃ©todo que no recibe `self`.
* `@classmethod` â†’ recibe `cls` en vez de `self`.
* `@property` â†’ convierte un mÃ©todo en un atributo calculado.

```python
class Circulo:
    def __init__(self, radio):
        self.radio = radio

    @property
    def area(self):
        from math import pi
        return pi * self.radio**2
```

---

## ğŸ§© Mini-ejercicios rÃ¡pidos

1. Crea un decorador `@contador` que muestre cuÃ¡ntas veces se ha llamado una funciÃ³n.
2. Crea un decorador `@cronometro` que mida el tiempo de ejecuciÃ³n de una funciÃ³n.
3. Define una funciÃ³n anidada `multiplicador(factor)` que devuelva otra funciÃ³n que multiplique por ese factor.

---

## âœ… Checklist de dominio

* [ ] Â¿Entiendo la diferencia entre funciÃ³n anidada y closure?
* [ ] Â¿Uso `@wraps` (de `functools`) si quiero preservar nombre y docstring de la funciÃ³n decorada?
* [ ] Â¿SÃ© aplicar decoradores integrados (`@staticmethod`, `@classmethod`, `@property`)?
* [ ] Â¿SÃ© encadenar decoradores en el orden correcto?