# ğŸ§­ SesiÃ³n 3 Â· Punto 2 â€” EncapsulaciÃ³n y abstracciÃ³n bÃ¡sica

## ğŸ¯ Objetivos especÃ­ficos

* Entender el concepto de **encapsulaciÃ³n** en Python.
* Diferenciar entre atributos/mÃ©todos pÃºblicos, protegidos y privados.
* Introducir la **abstracciÃ³n** con clases base y mÃ©todos abstractos.
* Aplicar estos conceptos en un diseÃ±o simple de clases.

---

## ğŸ“š Resumen teÃ³rico-prÃ¡ctico

### ğŸ”¹ EncapsulaciÃ³n en Python

Python no tiene modificadores de acceso estrictos como Java o C#, pero sigue una **convenciÃ³n de nombres**:

* **PÃºblico**: acceso libre.

  ```python
  self.nombre
  ```

* **Protegido** (convenciÃ³n): un guion bajo.

  ```python
  self._saldo
  ```

  ğŸ‘‰ Indica â€œuso internoâ€, pero se puede acceder desde fuera si se fuerza.

* **Privado** (name mangling): doble guion bajo.

  ```python
  self.__password
  ```

  ğŸ‘‰ Python renombra internamente â†’ `_Clase__password`.

Ejemplo:

```python
class Cuenta:
    def __init__(self, titular, saldo):
        self.titular = titular    # pÃºblico
        self._saldo = saldo       # protegido
        self.__password = "1234"  # privado

    def get_saldo(self, pwd):
        if pwd == self.__password:
            return self._saldo
        else:
            raise PermissionError("ContraseÃ±a incorrecta")
```

---

### ğŸ”¹ Getters y setters (propiedades en Python)

En lugar de mÃ©todos `get/set`, se usan **`@property`** y **`@atributo.setter`**:

```python
class Producto:
    def __init__(self, nombre, precio):
        self._precio = precio
        self.nombre = nombre

    @property
    def precio(self):
        return self._precio

    @precio.setter
    def precio(self, nuevo_precio):
        if nuevo_precio < 0:
            raise ValueError("El precio no puede ser negativo")
        self._precio = nuevo_precio
```

Uso:

```python
p = Producto("Teclado", 20)
print(p.precio)   # 20
p.precio = 25     # setter validado
```

---

### ğŸ”¹ AbstracciÃ³n con clases base

Permite definir una interfaz que obliga a implementar ciertos mÃ©todos en las subclases.

```python
from abc import ABC, abstractmethod

class Figura(ABC):
    @abstractmethod
    def area(self):
        pass

class Rectangulo(Figura):
    def __init__(self, ancho, alto):
        self.ancho = ancho
        self.alto = alto

    def area(self):
        return self.ancho * self.alto
```

Uso:

```python
f = Rectangulo(5, 10)
print(f.area())  # 50
```

ğŸ‘‰ No puedes instanciar `Figura` directamente porque tiene un mÃ©todo abstracto.

---

## ğŸ§© Mini-ejercicios rÃ¡pidos

1. Crea una clase `CuentaBancaria` con un atributo protegido `_saldo` y un mÃ©todo `depositar`. AÃ±ade un mÃ©todo `retirar` que valide que no se quede en negativo.
2. Define una clase `Vehiculo` como abstracta con mÃ©todo `mover()`. Implementa `Coche` y `Bicicleta` que hereden de ella.
3. Implementa `@property` en una clase `Empleado` para que el atributo `salario` nunca pueda ser menor que 1000.

---

## âœ… Checklist de dominio

* [ ] Â¿SÃ© diferenciar entre atributos pÃºblicos, protegidos y privados en Python?
* [ ] Â¿SÃ© aplicar `@property` para encapsular la lÃ³gica de acceso a atributos?
* [ ] Â¿Entiendo que las clases abstractas no se pueden instanciar directamente?
* [ ] Â¿Puedo obligar a que una subclase implemente ciertos mÃ©todos con `@abstractmethod`?