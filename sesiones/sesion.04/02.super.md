# ğŸ§­ SesiÃ³n 4 Â· Punto 2 â€” Uso de `super()`

## ğŸ¯ Objetivos especÃ­ficos

* Comprender quÃ© hace `super()` en Python.
* Aprender a reutilizar y extender mÃ©todos de la clase base.
* Aplicar `super()` en **constructores** (`__init__`) y en mÃ©todos sobreescritos.
* Analizar cÃ³mo interactÃºa con la **herencia mÃºltiple** y el MRO.

---

## ğŸ“š Resumen teÃ³rico-prÃ¡ctico

### ğŸ”¹ `super()` en constructores

Permite inicializar correctamente atributos de la clase base sin repetir cÃ³digo.

```python
class Usuario:
    def __init__(self, nombre, email):
        self.nombre = nombre
        self.email = email

class Admin(Usuario):
    def __init__(self, nombre, email, permisos):
        super().__init__(nombre, email)  # inicializa parte de Usuario
        self.permisos = permisos
```

Uso:

```python
a = Admin("Ana", "ana@test.com", ["borrar", "crear"])
print(a.nombre, a.email, a.permisos)
```

---

### ğŸ”¹ `super()` en mÃ©todos sobreescritos

Permite aÃ±adir lÃ³gica **antes o despuÃ©s** del mÃ©todo de la clase padre.

```python
class Logger:
    def log(self, msg):
        print("[LOG]", msg)

class LoggerTiempo(Logger):
    def log(self, msg):
        from datetime import datetime
        super().log(f"{datetime.now()} - {msg}")
```

Uso:

```python
l = LoggerTiempo()
l.log("Usuario creado")
```

---

### ğŸ”¹ `super()` en herencia mÃºltiple

Con MRO, `super()` **no siempre apunta a la clase padre inmediata**, sino a la siguiente en el orden de resoluciÃ³n.

```python
class A:
    def saludar(self): print("A")

class B(A):
    def saludar(self):
        print("B antes")
        super().saludar()
        print("B despuÃ©s")

class C(A):
    def saludar(self):
        print("C antes")
        super().saludar()
        print("C despuÃ©s")

class D(B, C):
    def saludar(self):
        print("D")
        super().saludar()

d = D()
d.saludar()
print(D.mro())
```

Salida esperada:

```
D
B antes
C antes
A
C despuÃ©s
B despuÃ©s
```

ğŸ‘‰ AquÃ­ `super()` respeta el MRO: D â†’ B â†’ C â†’ A.

---

## ğŸ§© Mini-ejercicios rÃ¡pidos

1. Extiende la clase `Usuario` (del Lab 3) con una subclase `Moderador`. Haz que su `__init__` use `super()` para inicializar nombre/email/rol, y aÃ±ada un campo `nivel`.
2. Crea una clase `Logger` y otra `LoggerDebug`. Sobreescribe `log()` en `LoggerDebug` para aÃ±adir un prefijo `[DEBUG]` usando `super()`.
3. DiseÃ±a un diamante simple (A â†’ B, A â†’ C, D hereda de B y C) y observa el orden de ejecuciÃ³n con `super()` y `print()`.

---

## âœ… Checklist de dominio

* [ ] Â¿SÃ© usar `super().__init__()` para inicializar correctamente subclases?
* [ ] Â¿Puedo extender mÃ©todos existentes sin reescribir toda la lÃ³gica?
* [ ] Â¿Entiendo que en herencia mÃºltiple, `super()` sigue el **MRO**, no solo â€œel padre inmediatoâ€?
* [ ] Â¿SÃ© imprimir `Clase.mro()` para entender cÃ³mo fluye `super()`?